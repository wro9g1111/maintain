# 2020-09  
<img src='https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgithub.com%2Fnaver%2Ffe-news%2F2020-10' align=right>

# 링크 & 읽을거리

## [Introducing the New JSX Transform](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html)

JSX는 일반 JavaScript 코드로 transpile 되지 않으면, 브라우저는 이해하지 못한다. 따라서 아래와 예제 코드와 같이 작성된 코드는 React.createElement를 사용하도록 변환된다.

```js
import React from 'react';

// 작성된 코드
function App() {
  return <h1>Hello World</h1>;
}

// 변환된 코드
function App() {
  return React.createElement('h1', null, 'Hello world');
}
```

그러나, `React.createElement`의 사용은 다음의 2가지 문제가 존재한다.
- React 스코프 내에 있어야 하는 문제 (즉, React import를 필요)
- 적용된 일부 [성능 향상과 단순화]( https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#motivation)를 지원하지 못하는 문제

새로운 Transform은 [Babel 개발팀과의 협업](https://babeljs.io/blog/2020/03/16/7.9.0#a-new-jsx-transform-11154httpsgithubcombabelbabelpull11154)을 통해 다음의 이점들을 제공한다.
- React import 없이 JSX를 사용
- 번들 크기의 개선(사용자의 설정 환경에 따라 다를 수 있다.)
- 학습이 필요한 React의 개념적 부분을 감소시켜 주는 개선을 활성화한다.

새로운 Transform은 `React 17`(향후 0.14.x, 15.x, 16.x 들도 지원 예정)을 통해 사용할 수 있으며, 컴파일러(Babel, TS) 전용 entry point를 제공해 `React.createElement` 대신 특별한 함수를 자동으로 import 하고 사용하도록 변환된다.

```js
// 작성된 코드 (React import 없이 작성)
function App() {
  return <h1>Hello World</h1>;
}

// 변환된 코드 (아래 모듈은 컴파일러를 통해 자동 import)
import {jsx as _jsx} from 'react/jsx-runtime';

function App() {
  return _jsx('h1', { children: 'Hello world' });
}
```

## [We now generally consider Moment to be a legacy project in maintenance mode](https://momentjs.com/docs/#/-project-status/)
Moment 라이브러리가 더 이상의 기능 추가 없이 유지보수만 하게 되었습니다.

### 대안 라이브러리
- [Luxon](https://moment.github.io/luxon/): Moment의 진화로 생각할 수 있습니다. 오랜 기간 Moment 컨트리뷰터인 Isaac Cambron이 개발하였습니다.
- [Day.js](https://day.js.org/): 유사한 API를 사용하여 Moment를 최소한으로 대체하도록 설계되었습니다.
- [data-fns](https://date-fns.org/): Data 객체를 조작하기 위한 다양한 함수를 제공합니다.
- [js-Joda](https://js-joda.github.io/js-joda/): JSR-310 기반의 Java SE8 java.time 패키지를 포팅.

## [Effective limited parallel execution in JavaScript](https://medium.com/@arsenyyankovsky/effective-limited-parallel-execution-in-javascript-ea2a1fb9a632)
병렬 실행에 효과적으로 제한을 두는 방법입니다.

간단한 예제를 통해서 적절하게 병렬 실행을 제한 할 수 있는 방법을 가르쳐 줍니다.
[promise-pool](https://www.npmjs.com/package/@supercharge/promise-pool)

<img src=https://miro.medium.com/max/700/1*p0wnV6WLTPniBGkdhQN_ZA.png>

# 튜토리얼

## [React Component Patterns](https://dev.to/alexi_be3/react-component-patterns-49ho)

<img src=https://res.cloudinary.com/practicaldev/image/fetch/s--UeS3tK9Z--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/i/lke2ahq6bgrl99ns6cht.png width=500>

다양한 React Component 패턴(Compound, Flexible Compound 그리고 Provider Pattern)들을 소개하고, 각 패턴들의 사용이 어떤 경우에 적합한지 그리고 각각의 trade-offs 들을 소개한다.

## [React-use hooks](https://github.com/streamich/react-use?fbclid=IwAR0dAgNKsxJAbxoU8VhJ87esulCxP2AyVoxQb_R01O6nM0B44MPyeYfGvEA)
React에서 사용하는 커스톰 hook입니다. 유용한 hook이 많이 있으니 개발하실 때 우선 만들기 보다 필요한 hook을 찾아 보세요.

## [Logical assignment operators in JavaScript](https://dev.to/hemanth/logical-assignment-operators-in-javascript-inh?utm_source=ESnextNews.com&utm_medium=Weekly+Newsletter&utm_campaign=2020-09-01)
논리 할당 연산자가 추가될 예정입니다. 현재는 [stage-4](https://dev.to/hemanth/stage-4-features-5a26) 입니다. 
```javascript
//"Or Or Equals"
x ||= y;
x || (x = y);
```
```javascript
// "And And Equals"
x &&= y;
x && (x = y);
```
```javascript
// "And And Equals"
x &&= y;
x && (x = y);
```

## [A Gentle Introduction to Code Splitting with React](https://blog.kommit.co/a-gentle-introduction-to-code-splitting-with-react-395ddf44b71b)
React를 사용한 프로젝트에서 코드 분할에 대한 방법을 설명하고 있습니다.

### 분할하는 방법
1. Route level
```jsx
import React, { Suspense } from 'react';
import { Location, Router } from '@reach/router';

import Loading from './components/Loading';

const Home = React.lazy(() => import('./components/Home'));
const AppointmentForm = React.lazy(() => import('./components/AppointmentForm'));
const PreviousAppointments = React.lazy(() => import('./components/PreviousAppointments'));

class App extends React.Component {
  render() {
    return (
      <Location>
        {({ location }) => (
          <Suspense fallback={<Loading />}>
            <Router location={location}>
              <Home path="/" />
              <AppointmentForm path="/newAppointment" />
              <PreviousAppointments path="/previousAppointments" />
            </Router>
          </Suspense>
        )}
      </Location>
    );
  }
}
```
2. Component level
```jsx
class PreviousAppointments extends Component {
  constructor(props) {
    super(props);

    this.state = { map: null };

    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    import('./components/Map').then(module =>
      this.setState(() => ({
        map: module.default,
      })),
    );
  }

  render() {
    const { map: Map } = this.state;

    return (
      <>
        <div>Previous Appointments</div>
        ...
        {Map ? <Map /> : <button onClick={this.handleClick}>Show Map</button>}
      </>
    );
  }
}
```
이런 코드 분할 방법을 통해 성능을 높이고 사용자 경험을 최적화 시킬 수 있습니다.

## [Decorators](https://github.com/tc39/proposal-decorators)
2020년 9월에 제시된 데코레이터들 입니다.

몇 가지만 살펴 보면
### logged
메소드의 시작과 끝에 로그를 찍습니다.
```javascript
import { logged } from "./logged.mjs";

class C {
  @logged
  m(arg) {
    this.#x = arg;
  }

  @logged
  set #x(value) { }
}

new C().m(1);
// starting m with arguments 1
// starting set #x with arguments 1
// ending set #x
// ending m
```

### tracked
필드를 와하고 있다가 render 메소드를 트리거 합니다.
```javascript
import { tracked } from "./tracked.mjs";

class Element {
  @tracked counter = 0;

  increment() { this.counter++; }

  render() { console.log(counter); }
}

const e = new Element();
e.increment();  // logs 1
e.increment();  // logs 2

```

# 도구

## [Comlink](https://github.com/GoogleChromeLabs/comlink)

<img src=https://user-images.githubusercontent.com/234957/54164510-cdab2d80-4454-11e9-92d0-7356aa6c5746.png width=500>

> 예제 코드 이미지 (클릭하면 확대해서 볼수 있다.)

크롬 개발팀에서 공개한 아주 작은 크기(1.1kb)의 라이브러리로, WebWorkers 사용에 대한 초기 접근 장벽을 제거해 준다. 좀 더 추상적 수준에서 보자면, postMessage와 [ES6 Proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)에 대한 [RPC](https://ko.wikipedia.org/wiki/%EC%9B%90%EA%B2%A9_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%ED%98%B8%EC%B6%9C) 구현이라 할 수 있다.

Webpack을 번들러로 사용하고 있다면 [comlink-loader](https://github.com/GoogleChromeLabs/comlink-loader)를 같이 사용해, 코드의 일부 수정(또는 없이)을 통해 사용되는 모듈들을 WebWorkers 스레드에서 실행될 수 있도록 만들 수도 있다.

## [git CLI](https://cli.github.com/)
Github의 공식 CLI 툴이 Beta 기간을 끝내고, 얼마 전 1.0 버전을 선보였다. 터미널만으로 Github PR을 만들 수도 있고 관리도 할 수 있다.
